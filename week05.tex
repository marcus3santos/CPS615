\documentclass{prosper}%[pdf,azure,slideColor,colorBG]{prosper}
\hypersetup{pdfpagemode=FullScreen}

\usepackage{graphicx}
\usepackage{graphics}
\usepackage{rotating}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage{verbatim}

\usepackage{epsfig}

\newcommand{\quiz}[1]{{\hfill \tiny{$_{ #1}$}}}

\newcommand{\enfa}{{$\epsilon$-NFA}}
\newcommand{\e} {{\mbox{$\epsilon$}}}
\newcommand{\autom}[1]{$#1 = (Q, \delta, \Sigma, q_0, F)$}
\newcommand{\sg}{{\mbox{$\Sigma$}}}

\newcommand{\ra}{\mbox{$\;\rightarrow\;$}}
\newcommand{\vb}{\mbox{$\;|\:$}}
\newcommand{\dra}{\mbox{$\;\Rightarrow\;$}}
\newcommand{\cdra}{\mbox{$\;\stackrel{*}{\Rightarrow}\;$}}
\newcommand{\lmd}{\mbox{$\;\underset{lm}{\Rightarrow}\;$}}
\newcommand{\lmdstar}{\mbox{$\;\underset{lm}{\stackrel{*}{\Rightarrow}}\;$}}
\newcommand{\rmdstar}{\mbox{$\;\underset{rm}{\stackrel{*}{\Rightarrow}}\;$}}

\newcommand{\rmd}{\mbox{$\;\underset{rm}{\Rightarrow}\;$}}\newcommand{\cfg}[1]{$#1 = (V, \Sigma, R, S)$}
\newcommand{\qed}{{$\;\;\Box$}}

\begin{document}
\begin{slide}{Minimization of DFAs}
\begin{itemize}
\item "To minimize" a DFA, means to bring the number of DFA states to a minimum.
\item Why minimize? To save money and build smaller machines.
\item The minimization algorithm is based on the idea of merging all equivalent states. In essence:
\begin{enumerate}
\item Eliminate any state that cannot be reached from a start state.
\item Partition the remaining states into blocks of equivalent states so that no pair of states from different blocks are equivalent.
\end{enumerate}
\end{itemize}
\end{slide}

\begin{slide}{Partitioning of states}
Partitioning algorithm:\\
\begin{quote}
For each state $q$, construct a block that consists of $q$ and all states equivalent to $q$.
\end{quote}
\begin{tabular}{ll}
\includegraphics[scale=.23]{figures/re29.eps}
&
\includegraphics[scale=.23]{figures/re31.eps}
\end{tabular}
\begin{minipage}{7cm}
$(\{A, E\}, \{B, H\}, \{D, F \}, \underbrace{\{C \},  \{G\}})$\
\end{minipage}
\begin{itemize}
\item Notice that $C$ and $G$ are distinguishable from all other states. I.e., each is  equivalent only to itself.
\end{itemize}
\end{slide}

\begin{slide}{Partitioning of states: example}
\begin{tabular}{ll}
\includegraphics[scale=.4]{figures/re32.eps}
&
\includegraphics[scale=.4]{figures/re33.eps}
\end{tabular}
\begin{minipage}{10cm}
$(\{A, C, D\}, \{B, E\})$
\begin{itemize}
\item Notice: $\{C,D\}$ should not be included, because no pairs of states from different blocks are equivalent.
\end{itemize}
\end{minipage}
\end{slide}

\begin{slide}{DFA minimization algorithm}
Given DFA $A=(Q, \delta_A, \Sigma, q_0, F)$:%\autom{A}:
\begin{enumerate}
\item Remove unreachable states.
\item Use the TDFA to find all pairs of equivalent states.
\item Partition $Q$ into blocks of mutually equivalent states.
\item Construct the minimum-state equivalent DFA $B$ by using the blocks from step 3, as follows:
\begin{enumerate}
\item Let $S$ be a block (i.e., state of $B$), and $a\in\Sigma$. Then the transition function for $B$ is defined as:\\
\(
\delta_B(S,a)=T \), where $T$ is a block and $\delta_A(p,a) \in T$ for all states $p$  in $S$.
\item The start state of $B$ is the block containing the start state of $A$.
\item The set of accepting states of $B$ is the set of blocks containing accepting states of $A$.
\end{enumerate}
\end{enumerate}
\end{slide}


\begin{slide}{Example}
\begin{tabular}{l|l}
Minimizing & to obtain\\
\includegraphics[scale=.28]{figures/re29.eps}
&
\includegraphics[scale=.53]{figures/re34.eps}
\end{tabular}
\end{slide}




\begin{slide}{Exercise}
Draw the table of distinguishabilities  and use it to construct the minimum-state DFA for the DFA below
\begin{center}
\begin{tabular}{l}
\includegraphics[scale=.5]{figures/dfaToMinDFA.eps}\\
\end{tabular}
\end{center}
\end{slide}

\begin{slide}{Exercise}
Describe the error in the following ``proof'' that $0^*1^*$ is not a regular language.

Steps of the ``proof'':
\begin{enumerate}
\item Assume that $0^*1^*$ is regular.
\item Lep $p$ be the pumping length for $0^*1^*$.
\item Choose $w$ to be the string $0^p1^p$.
\item You know that $w$ is a member of $0^*1^*$.
\item But from an example shown in class we know that $w$ cannot be pumped. Thus you have a contradiction. 
\item So $0^*1^*$ is not regular.
\end{enumerate}
\end{slide}

\begin{slide}{Exercise}
Convert the following DFA to a RE using the state elimination-based algorithm.
\begin{center}
\begin{tabular}{l}
\includegraphics[scale=.5]{figures/exercises1.eps}\\
\end{tabular}
\end{center}
\end{slide}

\begin{slide}{Context-Free Grammars and Languages}
\begin{itemize}
\item We have studied Regular Languages and its descriptors: finite automata and regular expressions.
\begin{itemize}
\item we learned that even some simple languages are not regular, such as $\{(^n
)^n, n\geq 0\}$.
\item What kind of language are those? What descriptors do they have?
\end{itemize}
\item Today we will start studying {\blue context-free grammars} (CFG)\begin{itemize}
\item they are useful in a variety of applications, e.g., compilers, translators, specification of markup languages, etc.
\end{itemize}
\item CFGs define {\blue context-free languages} (CFL), which {\blue includes regular languages}.
%\begin{itemize}
%\item  CFGs turned the implementation of parsers into a routine job.
%\end{itemize}
\end{itemize}
\end{slide}

\begin{slide}{CFG: informal example}
Let $G_1$ be the following grammar. Let's see some new terminology:
\[
\begin{array}{l}
A \ra (A)\\
A\ra \epsilon\\
\end{array}
\]
\begin{itemize}
\item A {\blue grammar} is a collection of { substitution (production) rules}.
\item A {\blue rule} consists of a {\blue variable}, an '\ra' symbol, and a sequence of symbols consisting of variables and {\blue terminals}.
\item The {\blue start variable} occurs on the Left-Hand-Sside of the topmost rule.
\item For convenience, we may write the rules above as $A \ra (A)\vb \epsilon$
\end{itemize}
\end{slide}


\begin{slide}{Using a grammar to infer a string}
Inferring a string via a {\blue derivation}:
\begin{enumerate}
\item Write down the start variable.
\item Find  a variable that is written down and a rule that has that variable in the LHS,  then ``expand'' that variable by replacing it with the RHS of the rule.
\item Repeat step 2 until no variables remain.
\end{enumerate}
Example: a {\blue derivation} of string  $((()))$ using the grammar \[A\ra(A)\vb\epsilon\]
\[
A\dra(A)\dra((A))\dra(((A)))\dra((()))
\]
Notice: '\dra' denotes a derivation step.
\end{slide}

\begin{slide}{Formal Definition of CFG}
A CFG $G$ is a 4-tuple \cfg{G}, where:
\begin{itemize}
\item $V$ is a finite set called the {\blue variables}.
\item $\Sigma$ is a finite set, disjoint from $V$, called the {\blue terminals},
\item $R$ is a finite set of {\blue rules}, with each rule being a variable and  a string of variables and terminals, and
\item $S$ is the start symbol.
\end{itemize}
If $u$, $v$ and $w$ are strings of variables and terminals, and $A\ra w$ is a rule of the grammar, we say that
\[
\begin{array}{ll}
\bullet & uAv\mbox{\em\blue\ yields }uwv\mbox{, denoted }uAv\dra uwv\\
\bullet & u\cdra v \mbox{\ if } u= v\mbox{\ or } u\dra u_1\dra u_2\dra\cdots\dra u_k\dra v
\end{array}
\]
%The language of the grammar is $\{w\in \Sigma^* : S \cdra w\}$
\end{slide}

\begin{slide}{Example of derivation}
Let $G$ be the following grammar $G=(\{E, I\}, T, P, E)$, where,  $T = 
\{+, *, (, ), a, b, 0, 1\}$ and $P$ is the following set of productions:
\[
\begin{array}{l}
E \ra I \vb E+E\vb E*E\vb (E)\\
I\ra a\vb b \vb Ia \vb Ib \vb I0 \vb I1
\end{array}
\]
Derivation of $a * (a + b00)$: 
\begin{center}
\includegraphics[scale=.5]{figures/cfl2.eps}
\end{center}
Note: not all choices lead to successful derivations of a particular string, e.g.: $E\dra E+E$
\end{slide}

\begin{slide}{Leftmost and Rightmost Derivations}
\begin{itemize}
\item {\em Leftmost derivation} \lmd: Always replace the leftmost variable by one of its rule-bodies. 
\item {\em Rightmost derivation} \rmd: Always replace the rightmost variable by one of its rule-bodies.
\end{itemize}
Example: rightmost derivation of $a * (a + b00)$
\begin{minipage}{5cm}
\[
\begin{array}{ll}
E \ra &I \vb E+E\vb \\& E*E\vb (E)\\
I\ra &a\vb b \vb Ia  \vb \\&Ib \vb I0 \vb I1
\end{array}
\]
\end{minipage}
\begin{minipage}{3cm}

\begin{center}
\includegraphics[scale=.4]{figures/cfl3.eps}
\end{center}
\end{minipage}
\end{slide}

\begin{slide}{The language of a Grammar}
\begin{itemize}
\item The {\blue language of a grammar} $G$ with start symbol $S$ is the set of strings of terminals that have derivations from $S$, i.e.:
\[
L(G)=\{w\in\Sigma^*:S\cdra w\}
\]
\item If $G$ is a CFG, then we call $L(G)$  a {\blue context-free language}.
\end{itemize}
%Example: Let's prove that $L(G)$, where  $G$ is the grammar below, is the set of palindromes over $\{0,1\}$. 
%\[
%P \ra 0P0 \vb 1P1 \vb 1 \vb 0 \vb \e
%\]
\end{slide}

\begin{slide}{Designing CFGs}
The structure of strings in a CFL can be of two basic kinds:
\begin{itemize}
\item  a string with multiple regions that must occur in some fixed order but do not have any correspondence between each other, e.g.. $a^*(b^*+c^*)$. In that case, to generate such  string use a rule of the form
\[
A \ra BC \cdots
\]
\item a string with two regions that must occur in some fixed order and must correspond to each other, e.g., $\{a^nb^n: n\geq 1\}$. In that case,  to generate such string start at the outside edges of the string and generate toward the middle.
\end{itemize}
\end{slide}


\begin{slide}{Exercises}
Design CFG for the following languages:
\begin{itemize}
\item $a^*$
\item $a^*b(ba^*b+a)^*$
\item $\{a^nb^n: n\geq 1\}$
% A -> aAb | ab
\item $\{a^ib^j: i\leq j\}$
% A -> aAb | Ab | e
%\item $\{a^nb^n: n\geq 1\}\cup \{a^ib^j: i< j\}$
\item $\{a^ib^j: i\neq j\}$
% A -> aAb | B | C
% B -> bB |b
% C -> aC | a
\end{itemize}
\end{slide}

\end{document}